// Generated by CoffeeScript 1.8.0
var Event, User, americano, log, momentTz,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

americano = require('americano-cozy');

momentTz = require('moment-timezone');

log = require('printit')({
  prefix: 'event:model'
});

User = require('./user');

module.exports = Event = americano.getModel('Event', {
  start: {
    type: String
  },
  end: {
    type: String
  },
  place: {
    type: String
  },
  details: {
    type: String
  },
  description: {
    type: String
  },
  rrule: {
    type: String
  },
  tags: {
    type: function(x) {
      return x;
    }
  },
  attendees: {
    type: [Object]
  },
  related: {
    type: String,
    "default": null
  },
  timezone: {
    type: String
  },
  alarms: {
    type: [Object]
  }
});

Event.dateFormat = 'YYYY-MM-DD';

Event.ambiguousDTFormat = 'YYYY-MM-DD[T]HH:mm:00';

Event.utcDTFormat = 'YYYY-MM-DD[T]HH:mm:00.000Z';

Event.alarmTriggRegex = /(\+?|-)PT?(\d+)(W|D|H|M|S)/;

require('cozy-ical').decorateEvent(Event);

Event.prototype.migrateDoctype = function() {
  this.start = this.migrateDateTime(this.start);
  this.end = this.migrateDateTime(this.end);
  if (this.rrule) {
    this.timezone = User.timezone;
  } else {
    this.timezone = void 0;
  }
  return this;
};

Event.prototype.migrateDateTime = function(dateStr) {
  var d, m;
  if (!dateStr) {
    return dateStr;
  }
  if (dateStr.length === 10 || dateStr.charAt(10) === 'T') {
    return dateStr;
  }
  d = dateStr;
  if (__indexOf.call(dateStr, "GMT") < 0) {
    d = d + " GMT+0000";
  }
  m = momentTz.tz(d, 'UTC');
  if (this.rrule) {
    return m.tz(User.timezone).format(Event.ambiguousDTFormat);
  } else {
    return m.format(Event.utcDTFormat);
  }
};

Event.all = function(params, callback) {
  return Event.request("all", params, callback);
};

Event.tags = function(callback) {
  return Event.rawRequest("tags", {
    group: true
  }, function(err, results) {
    var out, result, tag, type, _i, _len, _ref;
    if (err) {
      return callback(err);
    }
    out = {
      calendar: [],
      tag: []
    };
    for (_i = 0, _len = results.length; _i < _len; _i++) {
      result = results[_i];
      _ref = result.key, type = _ref[0], tag = _ref[1];
      out[type].push(tag);
    }
    return callback(null, out);
  });
};

Event.createOrGetIfImport = function(data, callback) {
  if (data["import"]) {
    return Event.request('byDate', {
      key: data.start
    }, function(err, events) {
      if (err) {
        log.error(err);
        return Event.create(data, callback);
      } else if (events.length === 0) {
        return Event.create(data, callback);
      } else if (data.description === events[0].description) {
        log.warn('Event already exists, it was not created.');
        return callback(null, events[0]);
      } else {
        return Event.create(data, callback);
      }
    });
  } else {
    return Event.create(data, callback);
  }
};

Event.prototype.formatStart = function(dateFormat) {
  var date;
  if (this.rrule) {
    date = momentTz.tz(this.start, this.timezone).format(dateFormat);
    date += ' ' + this.timezone;
  } else {
    date = momentTz.tz(this.start, User.timezone).format(dateFormat);
  }
  return date;
};

Event.prototype.getGuest = function(key) {
  var currentguest, guests, _ref;
  guests = ((_ref = this.attendees) != null ? _ref.toJSON() : void 0) || [];
  currentguest = guests.filter(function(guest) {
    return guest.key === key;
  })[0];
  if (currentguest) {
    currentguest.setStatus = (function(_this) {
      return function(status, callback) {
        currentguest.status = status;
        return _this.updateAttributes({
          attendees: guests
        }, callback);
      };
    })(this);
  }
  return currentguest;
};

Event.prototype.getAlarmAttendeesEmail = function() {
  return [User.email];
};
